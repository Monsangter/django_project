질문 등록 버튼

[파일이름: projects\mysite\templates\pybo\question_list.html]

</table>
    <a href="{% url 'pybo:question_create' %}" class="btn btn-primary">질문 등록하기</a>
</div>
{% endblock %}

앵커 태그이나, 부트스트랩의 btn btn-primary 클래스를 적용하면 버튼으로 보인다. 버튼을 클릭하면 앵커 테그의 url 호출.

=====

url 매핑

pybo:question_create 에 해당하는 url 매핑 규칙을 추가한다.

[파일명: projects\mysite\pybo\urls.py]

urlpatterns = [
    (... 생략 ...)
    path('question/create/', views.question_create, name='question_create'),
]

======
폼.

템플릿, 매핑 했으니 이제 뷰를 손봐줄 차례이나 폼에 대해 알아보자.

페이지 요청시 전달되는 파라미터들을 쉽게 관리하기 위한 클래스이다.

파라미터 값이 누락되지는 않았는지, 그 형식이 적절한지를 검증할 목적으로 사용한다. html 자동생성, 폼에 연결된 모델을 통해 데이터를 저장하느 ㄴ기능도 있다.

질문등록시 사용할 question form으 ㄹ만든다.

[파일명: projects\mysite\pybo\forms.py]

from django import forms
from pybo.models import Question


class QuestionForm(forms.ModelForm): #모델 폼을 상속한다. 장고의 폼에는 forms.Form, forms.ModelForm이 있는데, 모델 폼은 모델과 연결되어
                                     #폼을 저장하면 연결된 모델의 데이터를 저장할 수 있는 폼이다.
    class Meta:
        model = Question  # 사용할 모델
        fields = ['subject', 'content']  # QuestionForm에서 사용할 Question 모델의 속성
        
델 폼은 이너 클래스인 Meta 클래스가 반드시 필요하다. Meta 클래스에는 사용할 모델과 모델의 속성을 적어야 한다.
QuestionForm은 Question 모델과 연결된 폼이고 속성으로 Question 모델의 subject와 content를 사용한다고 정의한 것이다.

=====

뷰함수

views.question_create 함수 작성.

def question_create(request):
    form = QuestionForm()
    return render(request, 'pybo/question_form.html', {'form': form})

question_create 함수는 위에서 작성한 QuestionForm을 사용했다.
render 함수에 전달한 {'form': form}은 템플릿에서 질문 등록시 사용할 폼 엘리먼트를 생성할 때 쓰인다.

======
템플릿

pybo/question_form.html 템플릿을 다음과 같이 작성하자.

[파일명: projects\mysite\templates\pybo\question_form.html

{% extends 'base.html' %}
{% block content %}
<div class="container">
    <h5 class="my-3 border-bottom pb-2">질문등록</h5>
    <form method="post">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit" class="btn btn-primary">저장하기</button>
    </form>
</div>
{% endblock %}

{{ form.as_p }}의 form은 question_create 함수에서 전달한 QuestionForm의 객체이다. 
{{ form.as_p }}는 폼에 정의한 subject, content 속성에 해당하는 HTML 코드를 자동으로 생성한다.

<form method="post">에 액션을 명확히 지정하지 않았는데, 지정하지 않으면 현재 페이지의 url이 디폴트로 설정된다.
나중에 이 템플릿을 질문수정등 여러 기능에서 함께 사용해야할 수도 있으니 action속성을 비워뒀다.

<form method="post" action="{% url 'pybo:question_create' %}">
로 명확히 해놔도 된다.

==========
get 과 post

def question_create(request):
    if request.method == 'POST':
        form = QuestionForm(request.POST)
        if form.is_valid():
            question = form.save(commit=False)
            question.create_date = timezone.now()
            question.save()
            return redirect('pybo:index')
    else:
        form = QuestionForm()
    context = {'form': form}
    return render(request, 'pybo/question_form.html', context

질문 등록하기 버튼을 클릭한 경우에는 pybo/question/create/ 페이지가 GET 방식으로 요청되어 question_create 함수가 실행된다. 
왜냐하면 <a href="{% url 'pybo:question_create' %}" class="btn btn-primary">질문 등록하기</a>와 같이 링크를 통해 페이지를 요청할 경우에는 
무조건 GET 방식이 사용되기 때문이다

request.method 값이 GET이 되어 if .. else .. 구문에서 else 구문을 타게 되어 질문을 등록하는 화면을 렌더링한다.

질문 등록 화면에서 "저장하기" 버튼을 클릭하면 question_create 함수가 실행되고 request.method 값은 POST가 되어 다음 코드 블록이 실행될 것이다.
 
    if request.method == 'POST':
        form = QuestionForm(request.POST)
        if form.is_valid():  # 폼이 유효하다면
            question = form.save(commit=False)  # 임시 저장하여 question 객체를 리턴받는다.
            question.create_date = timezone.now()  # 실제 저장을 위해 작성일시를 설정한다.
            question.save()  # 데이터를 실제로 저장한다.
            return redirect('pybo:index')
            
POST 방식에서는 form = QuestionForm(request.POST) 처럼 request.POST를 인수로 생성했다.
request.POST에 담긴 subject, content 값이 QuestionForm의 subject, content 속성에 자동으로 저장되어 객체가 생성된다.

