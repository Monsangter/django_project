장고란? - 생활코딩 이고잉 

수업소개=

웹프레임을 찍어내는 공장.

필요한 웹페이지를 미리 만들고, 요청이 들어왔을때 응답하는 방식과 차별된다.

파이썬으로 웹페이지를 만드는 프로그램을 만들고, 요청시마다 프로그램이 요청에 맞는 웹페이지를 만들어 반환한다.

즉 단순한 코드 수정만으로도 1억개의 정적 페이지들을 한번에 바꾸는 효과를 누릴 수 있음.

일반 파이썬 언어로도 만들 수 있는데, 보안등의 구현이 어려움.

이런 공통적 작업을 미리 해둔 소프트 웨어를 웹프레임 워크라고 한다.

사용자마다 개인 맞춤형 페이지를 만드는 일도 가능 할 수 있다.

========

장고 설치

1. python3 -m pip install django

2.django-admin 을 치면 서브명령들이 나온다.

3.django-admin startproject [프로젝트명] 생성위치(. 사용시 현재 디렉토리)
프로젝트 생성시 여러 파일들이 자동 설치된다. 

settings는 웹프로젝트를 운영하는데 큰 도움이 되는 파일

urls는 사용자의 요청에 따라 누가 처리해줄 것인가? 라우팅

manage.py는 프로젝트디렉토리 바깥에 있는데 프로젝트를 하는데 중요한 유틸리티 파일

4, python3 manage.py 서브명령들 나옴.

5. python3 manage.py runserver 서버 실행
python3 manage.py runserver [ 포트번호] 
이미 디폴트 포트번호인 8000이 사용중이라면 포트번호를 이용해 서버 실행.

========
포트의 개념

하나의 아이피를 사용하는 서버 컴퓨터에 여러개의 서버 소프트웨어가 있을 수 있다.

서버 컴퓨터의 어떤 서버와 연결할 것인가에 따라 포트 번호를 달리 설정한다.(리스닝)

파이썬 개발서버는 디폴트가 8000이다. 

========
app만들기

프로젝트 안에도 url 이 있지만 실질적으로는 프로젝트 하에 앱이라는 단위를 만들어서 그 아래에 기능들을 구현하게 된다.
그리고 각 앱또한 urls를 가지게 된다.

앱 아래에는 뷰가 있으며, 뷰안에 여러가지 함수를 넣어 구체적인 구현을 하게 된다.

project의 url 에서 앱으로 라우팅, 앱의 url 에서 뷰의 함수들로 라우팅. 험수들은 모델을 거쳐 db와 통신하며, 
함수는 db값을 받아 html이나 json, xml파일을 만들어 클라이언트에 응답하게 된다.

django-admin startapp myapp
========
라우팅

라우트는 경로라는 뜻이다. 즉 누가 처리할 것인가를 지정하는 일. 
프로젝트 안 유알엘 주소 -  앱. 안 유알엘 주소 - 뷰.내. 함수

1. from django.urls import path, include include 함수 임포트.

2. urlpatters 에 path(‘’. include(‘myapp.urls’)) — myapp 앱 하의 urls 파일을 활용해라.

3. myapp의 url 에도 필요한 루트 적기. 

4.이제 views 파일을 설정한다. 

5.클라이언트에 정보를 제공하기 위한 함수. index를 만들어 보자. 
첫번째 인자로 요청되는 여러가지 정보들을 객체로 전달해주로 약속 돼 있다.

6.return 값으로는 http 를 이용해 응답해주겠다는 HttpResponse 객체로 응답해준다.
from django.shortcuts import render, HttpResponse 에서 임포트 해줘야 함.
인자로는 전송하고 싶은 값을 적어주면 된다. HttpResponse(‘welcome’)

7.이제 뷰 파일에 대한 라우팅이 필요한데, 
urls 파일에서, from myapp (myapp 패키지(앱파일))에 있는 views를 임포트하고
원하는 path의 두번째 인수에 views.index(views파일의 index함수) 를 넣어준다.

다른 페이지도 마찬가지인데, 가변적인 url들을 한번에 처리할 수도 있다.
path(‘read/<id>/‘, views.read) 꺽쇠안의 값은 가변적인 값을 뜻하고 id는 그 값에 부여된 변수라고 생각해도 된다.

뷰파일로 넘어가 id를 파라미터로 받아 리스폰스 할때 반영해줄 수도 있다. return HttpRespnse(‘Read’ + id)

============
장고를 쓰는 이유?

웹서버(아파치, 엔진엑스, iis) 말고, 장고 플라스크 등의 웹어플리케이션 서버등을 사용하는 것에 어떤 차이가 있는가?

웹서버를 정적, 웹프레임웍을 동적이라고 한다.

웹서버는 준비된 페이지를 보여준다. 성능이 빠르고, 배워야할게 없다. 그냥 설치후 실행하면 된다.

반면 웹어플리케이션 서버는 굉장히 느리다. (다만 컴퓨터의 성능이 요즘에는 좋기때문에 신경쓸정도는 아니다)
웹프레임워크도 공부해야하고 db도 공부해야하고 언어도 공부해야하고 할게 많다. 
다만 유지보수가 너무 쉽다. view등의 공장만 수정하면 모든 페이지가 바뀌기 때문에.
그리고 사용자가 접속시마다 웹페이지를 생성하기 때문에, 사용자에 알맞은 정보를 그때그때 만들어줄 수 있다.

ex) import random. return HttpResponse(‘<h1>Random</h1>’ + str(random.random()))
정적 서버에서 이런 구현은 불가.

=============

홈페이지 읽기 기능 구현하기

아무리 복잡한 웹도 기본적으로 4가지 기능으로 이뤄진다.

CRUD create, read, update, delete.

READ는 두가지 기능으로 이루어져 있다.

홈페이지(/)와 상세보기(/read/<id>/ 이다.

‘’’ 따옴표 세개면 어러 줄 작성 가능. html 작성 가능.
전역 변수에 대해서 함수내에서 수정을 해야할떄는 그 사용 함수에서 전역 변수로 불러와 줘야 한다.

파이썬 문법 사용 가능.
topics = [
	{‘id’:1, ‘title’:’routing’, ‘body’:’Routing is ..’}
	{‘id’:2, ‘title’:’view’, ‘body’:’view is ..’}
	{‘id’:3, ‘title’:’model’, ‘body’:’model is ..’}
]

def index(request){
ol = f’<li><a href=“/read/{topic[‘id’]}”>{topic[“title”]}</li>’
	for topic in topics:
	return HttpResponse(f’’’
	<ol>
		{ol}
	<ol>


================

템플릿 구현.

def HTMLTemplate(articleTag):
	global topics
	ol = ‘’
	for topic in topics:
		ol += f’<li><a href=“/read/{topic[“id”]}”>{topic[“title”]}</a></li>’
	return f’’’
	<html>
	<body>
		<h1><a href=“/“>django</a></h1>
		<ol>
			{ol}
		</ol>
		{articleTag}
	</body>
	</html>
	‘’’

df index(request):
	article = ‘’’
	<h2>Welcome</h2>
	Hello.Django
	‘’’
	return HttpRespnose(HTMLTemplate(article))

——read 구현

def read(request, id):
	global topics
	article = ‘’
	for topic in topics:
		if topic[‘id’] == int(id):
			article = f’<h2>{topic[“title”]}</h2>{topic[“body”]}’
	return HttpResponse(HTMLTemplate(article))

폭발적으로 성장한 것. 모듈화가 됨. 템플릿만 고쳐도 그 템플릿을 공유하는 페이지는 전부 한번에 고칠 수 있음.

=============

create 구현.

def create(request):
	article = ‘’’
		<form action=“/create”>
		<input type=“text” name=“title” placeholder=“title”> #place holder 로 입력창 설명, 
		#나중에 서버에 데이터 전송시 설정한 name 으로 전송됨.
		<p><textarea name =“body” placeholder = “body></textarea></p> 
		#여러줄의 택스트를 입력받을 때 사용하는 태그.
		<p><input type=“submit”></p>
		</form>
		#담겨 있는 데이터를 원하는 경로로 전송하기 위해서는 이 코드들을 폼으로 감싸야 한다.
		#경로는 action으로 설정
	‘’’
	return HttpResponse(HTMLTemplate(article))

==============
생성 기능 구현 2

http://localhost:8000/read/1/
http://localhost:8000/read/?id=1&mode=…(서버에 질의할떄 사용하는 쿼리스트링 )

요즘 트렌드에서는 위에 방식이 더 깔끔하기 때문에 위 방식을 사용한다.
어쨋든 둘다 서버로부터 url이 데이터를 겟하는 방식이다.

/create/?title=crud+is… 이런식의 url 은 서버에 있는 데이터를 변경하는 작업이다.
주소에 입력값이 포함돼 있다면, 공유시 클릭할때마다 글이 추가 되는 오류가 나올 수 있다. 
즉 변경시에는 쿼리스트링이 포함되면 절대로 안된다. 

이떄 post를 사용한다. post를 사용하면, 헤더라는 곳안에 데이터를 포함해서 눈에보이지 않게 보낼 수 있다.
폼에 디폴트는 겟방식이나, method = “post”를 추가해주면 포스트 방식으로 작동하게 된다.

payload확인시 url 이 아닌 다른 방식으로 정보를 전송한 것을 확인할 수 있다.

다만 장고의 보안 기능때문에 csrf보안을 추가하지 않으면, 오류가 나온다.

==============
생성 기능 구현 3

이제 요청이 겟으로 왔을때와 포스트로 왔을떄를 구분해보자. 


사용자 요청이 들어오면 장고가 요청을 받고 그것을 해석해서 뷰 안의 함수를 호출하는 것이다.
httprequest객체 를 인자로 받는데, 패키징된 여러가지 사용자들의 요청 정보들을 객체 형태로 만들어 공급하는 것이다.
그리고 http response를 통해 리턴 되는 것이다. 

장고 request를 구글링 해보면 

request.method를 통해 사용자가 요청을 get으로 보냈는지 post로 보냈는지 알 수 있다. 이것을 이용해 처리를 나눠줄 수 있다.

if request.method == ‘GET’:
elif request.method ==‘POST’:
